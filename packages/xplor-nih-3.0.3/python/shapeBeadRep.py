
"""
Tools to create a model of a molecular selection consisting of spherical beads
of varying radii.
"""
numBeadSets=0
segid="Z"
name="blob"
resName="bead"

from trace import notrace_decorate
@notrace_decorate
def create_BeadRep(selection="known and not PSEUDO",
                   resolution=5, #angstroms
                   startNumBeads=2,
                   mapTol=0.65,# required correlation with initial map
                   testGrad=False,# if True, bomb w/ gradient test
                   verbose=False,
                   writeMap=False,
                   writePDB=False,
                   ):
    """
    Create a spherical bead representation of the atoms specified in the
    selection argument. First, an atomic probability map is generated from
    the specified selection using the <m atomProb>.AtomProb facility with
    grid spacing specified by the resolution argument. Then beads are added,
    starting with startNumBeads. For a given number of beads, the position
    and radius of each bead is varied such that the generated AtomProb map
    matches as closely as possible the initial map generated by selection using
    a gradient optimization scheme. If the cross-correlation coefficient of
    the bead-generated map with the initial map is greater than the mapTol
    argument, the procedure stops, otherwise the set of beads is discarded
    and an increased number of beads in generated so that the minimization
    process is repeated.

    When mapTol is achieved, the bead atoms are created in the simulation
    corresponding to selection. The return object contains a named tuple with
    members beadAtoms, containing the created beads, and radii, containing
    the optimized radii,

    The created bead atoms' residue name and atom name are given by
    the module-local variables resName, and name, which take default
    value "bead" and "blob", respectivley. The segid takes the value Za,
    where a is replaced by the number of times this function is called.
    The chemType property is "Zb", where b is replaced by an index
    corresponding to bead number. This so that unique radii can be assigned
    by chemical type in the nonbonded term. We have found it useful to
    multiply the radii by the factor 1.4 to best represent occupied regions
    in a <m repelPot>.RepelPot energy term.    


    Additional arguments are:

        testGrad    - this flag can be set to True to test the gradient in
                      the position/radius optimization procedure.
        writeMap    - set this to True to write out the <m atomProb>,AtomProb
                      map associated with the bead representation in a file
                      named map-NUM.edm, where NUM is the number of beads.
        writePDB    - set this to True to write out the PDB associated with
                      the determined bead representation. In this PDB, the
                      radii are written to the B-factor PDB field in a file
                      named shape-NUM.pdb, where NUM is the number of beads.
        verbose     - If True, print information about the process of the
                      fitting procedure. Additional information printed for
                      integer verbose>1.

    """
    from atomSel import AtomSel
    from selectTools import convertToAtomSel
    selection=convertToAtomSel(selection)
    import protocol

    sim = selection.simulation()

    #2) generate atomic density map - specify resolution here
    from atomProb import AtomProb
    tmap = AtomProb(selection,[sim.atomPosArr()])
    tmap.setScaleType( 'volume' )
    tmap.xdelta= tmap.ydelta= tmap.zdelta= resolution
    #
    tmap.calc()

    from selectTools import numResidues
    #numAtoms=xsim.numAtoms()
    numBeads = startNumBeads#numResidues(xAtomSel)

    global pot
    global addedSel

    from xplorSimulation import XplorSimulation
    xsim = XplorSimulation(clone=False)
    xsim.disableOutput()

    import xplor
    global numEnergyCalls
    from atomSelAction import SetProperty
    numEnergyCalls=0
    def fun(params):
        global numEnergyCalls
        numEnergyCalls+=1
        q = params[:3*len(addedSel) ]
        q = [q[i:i+3] for i in range(0, len(q), 3)]
        r = params[3*len(addedSel): ]

        addedSel.apply( SetProperty( "pos", q) )
        pot.prStruct.setRadii(r)
        e  = pot.calcEnergy()
#        print 'energy: %.16f  correlation: %.5f'%(e,pot.correlation())
        return e

    def dfun(params):
        q = params[:3*len(addedSel) ]
        q = [q[i:i+3] for i in range(0, len(q), 3)]
        r = params[3*len(addedSel): ]
        
        addedSel.apply( SetProperty( "pos", q) )
        pot.prStruct.setRadii(r)

        from derivList import DerivList
        derivList = DerivList()
        derivList.init(xsim)
        e  = pot.calcEnergyAndDerivs( derivList )
        
        dEdR = pot.radiusGrad()

        dEdq = list( chain( *derivList[xsim] ) )

        #    print dEdR
        #    exit()

        grad = dEdq + list(dEdR)

        return grad

    segid="Z1"
    name="blob"
    resName="bead"
    numAtoms = len(selection)
    if verbose:
        print("generating beads to represent %d atoms." % numAtoms)
        pass
    while True:
        #3)  place \eta beads per residue at (backbone only?) atom positions.
        #    Initial width equal to half the distance to the adjacent beads
        #FIX: try backbone only
        prevPos=None
        radii=[]
        addedAtoms=[]
        from vec3 import norm
        if not radii: genRadii=True
        cnt=0
        for i in range(int(float(numAtoms)/(numBeads+1)),numAtoms,
                       int(float(numAtoms)/(numBeads+1))):
            if cnt>=numBeads:
                break
            cnt += 1
            #print i,numAtoms
            atom = selection[i]
            pos=atom.pos()
            addedAtoms.append( xsim.addAtom(name,i,resName,
                                            segmentName=segid,
                                            pos=pos,
                                            isPseudo=False) )
            nextPos = selection[i+1].pos() if i <numAtoms-1 else None
            if nextPos and prevPos:
                dist = 0.5*(norm(nextPos-pos) + norm(prevPos-pos))
            elif prevPos:
                dist = norm(prevPos-pos)
            else:
                dist = norm(nextPos-pos)
                pass
            if genRadii:
                radii.append(0.3*dist)
                pass
            prevPos = pos
            pass

        from selectTools import convertToAtomSel
        addedSel = convertToAtomSel(addedAtoms,xsim)

        from probDistPotTools import create_probDistPot
        pot=create_probDistPot("prob",tmap.getGrid(),addedSel,
                               potType="cross_correlation",scale=1)
        pot.setCalcRadiusGrad( True )
        pot.prStruct.setRadii( radii )
        pot.prStruct.setScaleType( 'volume' )

        if testGrad:
            from derivList import DerivList
            derivList = DerivList()
            derivList.init(xsim)
            e0 = pot.calcEnergyAndDerivs(derivList)
            delta = 1e-6
            print("grad wrt radius")
            for idx in range(len(radii)):
                r0=radii[idx]
                radii[idx] += delta
                pot.prStruct.setRadii( radii )
                e1 = pot.calcEnergyAndDerivs(derivList)
                radii[idx] = r0
            
                print(idx,(e1-e0)/delta, pot.radiusGrad()[idx])
                pass

            pot.prStruct.setRadii( radii )

            derivList.init(xsim)
            e0 = pot.calcEnergyAndDerivs(derivList)
            from vec3 import Vec3
            print("grad wrt x coord")
            for idx,atom in enumerate(addedSel):
                pos=Vec3( atom.pos() )
                deltaPos = Vec3(delta,0,0)
                atom.setPos( pos + deltaPos )
                xsim.sync()
                e1 = pot.calcEnergy()
                atom.setPos( pos )
                
                print(idx,(e1-e0)/delta, derivList[atom][0])
                pass
            exit()
            pass
        
        #4) use (gradient?) search to optimize position and radius of each bead w.r.t
        #   correlation of computed density map with previously generated
        from minimize import bfgs, conmin
        from itertools import chain
        q=list( chain( *[atom.pos() for atom in addedSel] ) )
        x=q+ list(radii)

        if verbose:
            print('numBeads: %d  Corr0: %.5f' % (numBeads,pot.correlation()))
            pass
    
        #global numEnergyCalls
        numEnergyCalls=0
        ret = conmin(x,fun,dfun,costTol=1e-2, gradTol=0.01, maxIters=50,)
        
        if verbose:
            print('              CorrF: %.5f'%pot.correlation(),end='')
            if verbose>1:
                print('   Energy calls: %d' % numEnergyCalls)
            else:
                print()
                pass
            pass

        r = ret[0][3*len(addedSel): ]

        if writeMap=="intermediate":
            pot.prStruct.writeEDM('map-%d.edm' % len(r))
            pass
        if writePDB=="intermediate":
            protocol.writePDB('shape-%d.pdb'%len(r),bFactors=r,
                              selection=addedSel)
            pass

        #create PDB with radius in b-factor field

        #5) if 1-correlation> tolerance, go to 3, increasing the number of beads
        if pot.correlation()>=mapTol:
            #print(r)
            break

        from math import ceil
        numBeads = ceil(numBeads * 1.5)

        del pot
        addedSel.deleteAtoms()
        del addedSel
        
        radii=[]
        pass
    if writeMap:
        pot.prStruct.writeEDM('map-%d.edm' % len(r))
        pass
    if writePDB:
        protocol.writePDB('shape-%d.pdb'%len(r),bFactors=r,
                          selection=addedSel)
        pass

    from xplorSimulation import getXplorSimulation
    global numBeadSets
    numBeadSets += 1
    segid="Z"+str(numBeadSets)
    
    sim = getXplorSimulation( selection.simulation() )
    returnAtoms=[]
    for cnt,atom in enumerate(addedSel):
        returnAtoms.append( sim.addAtom(atom.atomName(),
                                        atom.residueNum(),atom.residueName(),
                                        segmentName=segid,
                                        chemicalType="Z"+str(cnt),
                                        mass=0,
                                        pos=atom.pos(),
                                        isPseudo=False) )
        pass

    del pot
    del addedSel

    from collections import namedtuple
    BeadRepRet = namedtuple('BeadRepRet',['beadAtoms','radii'])

    import protocol
    protocol.updatePseudoAtoms(sim)
                            
    return BeadRepRet(convertToAtomSel(returnAtoms),r)
