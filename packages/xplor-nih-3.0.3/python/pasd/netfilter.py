
#
#
#
#
#
import trace
@trace.notrace_decorate
def netFilter(pots,
              potsToFilter=None,
              selection="not PSEUDO",
              failedFiltersCutoff= 0,
              minSALikelihood=-1,
              numIters=5,
              createExceptions=True,
              preferIntra=True,
              expectDiagPAs=False,
              printResiduePairScores=False,
              initScoresFrom="degen",
              includeBBSeq=False,
              includeBB=True,
              minPeakScore=0.01,
              passFrac=0.01,
              minExpectedScore=0.2,
              knownContacts=[],
              bbSel=" or ".join(["name "+n for n in
                                 "HN HA HA* HB HB* C CA N O".split()]),
              # old def:
              #bbSel=" or ".join(["name "+n for n in
              #                   "HN HA HA* HB HB*".split()]),
              verbose=True,
              tclOutput=False
              ):
    """
    Network filter, implemented with residue-by-residue scoring. Arguments:
      pots                   - a sequence of <m pasd>.PASDPot terms
      potsToFilter           - PASDPot terms whose PeakAssignments are be
                               filtered with a contact map generated by
                               contact map. [pots]
      selection              - <m atomSel>.AtomSel specifying which residues
                               are to be considered.  ["not PSEUDO"]
      failedFiltersCutoff    - the number of failed filters allowed for
                               further processing of a PeakAssignment. [0]
      minSALikelihood        - ignore shift assignments with previous
                               likelihoods smaller than this. [-1]
      numIters               - number of network filter iterations. [5]
      createExceptions       - boolean specifying whether inverse exceptions
                               are created. [True]
      preferIntra            - boolean. If True, always assign intraresidue
                               and sequential assignments likelihood 1.
                               Otherwise, these these the same as any other
                               sort of assignment. [True]
      expectDiagPAs          - boolean specifying whether diagonal peaks are
                               present in the spectra where the from- shift
                               assignment is the same as the to- shift
                               assignment. [False]
      printResiduePairScores - boolean. Whether or not to print final residue
                               pair score information. [False]
      includeBBSeq           - boolean. If True, include backbone-sequential
                               shift assignments to each residue's
                               neighborhood. [False]
      includeBB              - boolean deciding whether intraresidue SAs
                               members of each residue neighborhood consider
                               only sidechains. [True]
      initScoresFrom         - specify how to initialize peak assignment
                               scores. Valid values are
                                  "previous" - initialize from previous
                                               likelihoods
                                  "uniform"  - set all assignments to have
                                               equal weight
                                  "contacts" - set peak assignment score to 1,
                                               if it corresponds to a contact
                                               specified in knownContacts, else
                                               0.
                                  "degen"    - set score to 1/num assignments
                                               for each peak. The is the
                                               default.
      minPeakScore           - If the largest residue pair score is smaller
                               than this value, all peak assignments for a
                               peak are given zero values. [0.01]
      passFrac               - A pair of residues is considered in contact if
                               its normalized residue pair score is greater
                               than this value. [0.01]
      minExpectedScore       - smallest expected raw intraresidue residue pair
                               score. R_{min} in the reference below. [0.1]
      knownContacts <seq>    - a sequence of pairs of AtomSels specifying
                               contacts known a priori.
      bbSel                  - AtomSel specifying backbone protons. It is
                               used to determine whether a peak assignment
                               is sequential (to/from resids must be +/-1,
                               and both protons backbone), and for the
                               includeBB and includeBBseq logic.
      verbose                - boolean. Whether or not to print out
                               informational messages.



   raw residue pair score between residues a,b:

       R(a,b) = 1/N_R(a,b)\sum_s\sum_{m,n} \sigma(m,n;s)

   where N_R is the total possible number of to-from and from-to shift
   assignments for this pair of residues in all spectra. The first sum is
   over all spectra s, while the second sum is over all possible shift
   assignments m,n is spectrum s. \sigma(m,n;s) is an iteratively
   determined connection weight.

   A normalized residue pair score R'(a,b) is then computed as

      R'(a,b) = R(a,b) / sqrt(R_self(a) r_self(b))

   where
                    / R(a,a) if R(a,a)>R_{min}
       R_self(a)  = |
                    \ 1      otherwise

   \sigma(m,n;s) is initialized based on the initScoresFrom argument.


   If R(a,b) > passFrac, residues a and b are considered in contact and all
   peaks assignments which connect these residues are given likelihoods of
   1.
    
   Reference:

           J.J. Kuszewski, R. Augustine Thottungal, G.M. Clore, and
    	   C.D. Schwieters, ``Automated error-tolerant macromolecular
   	   structure determination from multidimensional nuclear
	   Overhauser enhancement spectra and chemical shift assignments:
	   improved robustness and performance of the PASD
    	   algorithm,'' J. Biomol. NMR 41, 221-239 (2008); PMID: 18668206.


    
                               
    """

    # 
    # NOTE:  this requires all SAs, Peaks, and PAs to have 
    #  unique names across all pots!  
    #  Better throw an error if they're not unique.
    #

    if potsToFilter==None: potsToFilter = pots
    from selectTools import convertToAtomSel
    selection=convertToAtomSel(selection)
    bbSel=convertToAtomSel(bbSel,selection.simulation())
    remarks=""

    from selectTools import getSegsResidues
    segsResids = getSegsResidues(selection)

    # array of unique segid,residue pairs
    # need map of seg,resid --> index
    residuesToIndex={}
    residues=[]
    for seg in list(segsResids.keys()):
        for resid in [r.resid for r in segsResids[seg]]:
            residuesToIndex.setdefault(seg,{})[resid] = len(residues)
            residues.append( (seg,resid) )
            pass
        pass
    potNameForSA=[]
    nameToSAindex={}
    fromSAindices=[]
    toSAindices=[]
    saToResidueIndex=[]
    saIsBackbone=[]
    toFromPartner=[]
    numSAsForPot={}
    sas=[]
    import atomSel
    
    def residuesInSel(sel):
        " Return list of indices into residues array"
        segsResids = getSegsResidues(sel)
        ret=[]
        for seg in list(segsResids.keys()):
            for resid in [r.resid for r in segsResids[seg]]:
                ret.append( residuesToIndex[seg][resid] )
                pass
            pass
        return ret
    
    
    def resPairForPA(pa):
        "Given a PA, return indices to the corresponding residue pair."
    
        fromSel=pa.fromAssignment().protonSelection()
        toSel=pa.toAssignment().protonSelection()
    
        fromResidues = residuesInSel( fromSel )
        toResidues   = residuesInSel( toSel   )
    
        ret = [[(fromRes,toRes) for toRes in toResidues] for
               fromRes in fromResidues]
        if len(ret)!=1:
            raise Exception("resPairForPA: internal error")
        
        return tuple(ret[0])
    
    def filterPAs(pots,
                  contactMap,
                  resPairScore):
        """
          Filter PeakAssignments using the contact map.    
        
         for each PA, declare it passed the filter if its corresponding residue 
         pair passed the filter
         
         Also, set previous likelihoods for each PA:
          -if the PA's residue pair didn't pass the filter, set its likelihood 
           to zero, else 1
    Alternate logic, not currently active:
          -if it did, set its likelihood to its resPairScore/max(resPairScores)
           of all passing PAs of this peak
        
        """
    
        nPAsPassed=0
        nPAsFailed=0
    
        for pot in pots:
            for peak in pot.peaks():
                #
                # find max resPairScore for passing PAs in this peak
                #
                maxResPairScore= -1
    
                for pa in peak.peakAssignments():
                    #FIX - CDS: don't think we want following line in
                    # production code                    
                    pa.resetNumFiltersFailed()
                    
                    paFailed=True
                    for resPair in resPairForPA(pa):
                        if contactMap[resPair]:
                            paFailed=False
                            maxResPairScore = max(maxResPairScore,
                                                  resPairScore[resPair])
                            pass
                        pass
    
                    if not paFailed:
                        nPAsPassed += 1
                        pa.setPreviousLikelihood(1.0)
                    else:
                        pa.incrementNumFiltersFailed()
                        pa.setPreviousLikelihood(.0)
                        nPAsFailed += 1
                        pass
                    pass
    
#unused logic - for setting prev likelihood to value between 0 and 1.
#                #
#                # now calculate new previous likelihoods for each passing PA
#                #
#                for pa in peak.peakAssignments():
#                    paResPairScore= -1
#                    paFailed = True
#                    for resPair in resPairForPA(pa):
#                        if contactMap[resPair]:
#                            paFailed = False
#                            paResPairScore = max(paResPairScore,
#                                                 resPairScore[resPair])
#                            pass
#                        pass
#    
#                    if not paFailed: ** the 2nd line overrides the 1st
#                        pa.setPreviousLikelihood( paResPairScore /
#                                                  maxResPairScore )
#                        pa.setPreviousLikelihood=1.0
#                        pass
#                    pass
                pass
            pass
        return (nPAsPassed, nPAsFailed)
    
    for pot in pots:
        for sa in pot.shiftAssignments():
	    #
	    # Don't include SAs that have low likelihoods or missing proton 
	    # shifts in any scoring at all.
	    #
            if sa.previousLikelihood() < minSALikelihood:
                continue
            if not sa.hasProtonShift():
                continue
	    
            saIndex = len(sas)
            sas.append(sa)
            nameToSAindex[sa.name()] = saIndex
            potNameForSA.append( pot.instanceName() )

	    #
	    # record which residue(s) this SA is part of
	    #
            saToResidueIndex.append( residuesInSel(sa.protonSelection()) )

	    #
	    # record from/to SA names separately
	    #
            if sa.isFrom():
                fromSAindices.append( saIndex )
            else:
                toSAindices.append( saIndex)
                pass
            
            #
            # record whether this SA is a backbone one
            #
            saIsBackbone.append( atomSel.intersect(bbSel,
                                                   sa.protonSelection()) )
            
            #
            # make sure an SA's toFromPartner is OK to be included before 
            # recording it
            #
            partnerName = "NONE"
            if (sa.hasToFromPartnerName() and
                pot.hasShiftAssignmentNamed( sa.toFromPartnerName() ) ):
                tempSA = pot.shiftAssignmentNamed( sa.toFromPartnerName() )
                if not ( tempSA.previousLikelihood() < minSALikelihood or
                         not tempSA.hasProtonShift() ):
                    partnerName = sa.toFromPartnerName()
                    pass
                pass
            toFromPartner.append(partnerName)
            pass
        numSAsForPot[pot.instanceName()] = len(potNameForSA)
        pass

    #convert array from names to indices
    toFromPartner = [ nameToSAindex[name] if name!='NONE' else 'NONE'
                      for name in toFromPartner]

#    fromSAnames.sort()
#    toSAnames.sort()


    #
    # build neighborhood lists for each residue:
    #

    #
    # initialize arrays of from and to SAs that 
    # are used to calculate residue pair score
    #
    fromSAsInResHood=[list() for i in range(len(residues))]
    toSAsInResHood   =[list() for i in range(len(residues))]

    #
    # make intraresidue SAs members of each residue neighborhood, optionally
    # including backbone atoms
    #
    for saIndex in range(len(saToResidueIndex)):
        if includeBB or not saIsBackbone[saIndex]:
            for resIndex in saToResidueIndex[saIndex]:
                if sas[saIndex].isFrom(): 
                    fromSAsInResHood[resIndex].append(saIndex)
                else:
                    toSAsInResHood[resIndex].append(saIndex)
                    pass
                pass
            pass
        pass


    #
    # optionally, add backbone-sequential SAs to each residue's neighborhood
    #
    if includeBBSeq:
        #FIX: not tested
        for saName in list(saToResidueIndex.values()):
            if not saIsBackbone(saName):
                continue
            for res in saToResidueIndex[saName]:

                prevRes=previousResidue(res)
                nextRes = nextResidue(res)
                if sas[nameToSAindex[saName]].isFrom(saName):
                    fromSAsInResHood(prevRes).append(saName)
                    fromSAsInResidueNeighborhood(nextRes).append(saName)
                else:
                    toSAsInResidueNeighborhood(prevRes).append(saName)
                    toSAsInResidueNeighborhood(nextRes).append(saName)
                    pass
                pass
            pass
        pass

    #
    # initialize SA pair to PA index and set up SA pair score array
    #
    from cdsMatrix import CDSMatrix_double as RMat
    rawSAPairScore = RMat(len(sas),len(sas),0)
    saPairToResPair = {}

    
    if verbose:
        print("num from/to shift assignments: %d/%d" % (len(fromSAindices),
                                                        len(toSAindices)))
        pass

    #saToResidueIndex = numpy.array(saToResidueIndex)
    from atomSel import AtomSel
    restype=[AtomSel("name CA and resid %d"%resid)[0].residueName()
             for resid in [t[1] for t in residues]]
    numResidPairs=0
    for fromSAindex in fromSAindices:
        for toSAindex in toSAindices:
            if potNameForSA[fromSAindex] != potNameForSA[toSAindex]:
                continue
            residPairs=list(zip(saToResidueIndex[fromSAindex],
                           saToResidueIndex[toSAindex]  ))
#            print residPairs
            if len(residPairs)>0:

                key = (fromSAindex,toSAindex)
                saPairToResPair[key] = residPairs
#                print "residPairs: %s %s" % (sas[fromSAindex].name(),
#                                             sas[toSAindex].name()),
#                r1,r2=residPairs[0]
#                print residues[r1][0],"%d %s"%(residues[r1][1],restype[r1]),
#                print residues[r2][0],"%d %s"%(residues[r2][1],restype[r2])
                numResidPairs += len(residPairs)
                pass
            pass
        pass

    if verbose:
        print("num residPairs:", numResidPairs)
        pass

    #
    # read in peakAssignments that have acceptable numbers of failed filters 
    # and do not reference shiftAssignments that have been excluded (for low 
    # likelihood, or missing chemical shift, at the top of this function), and 
    # initialize their scores
    #
    
    if verbose:
        print("Reading peakAssignments... ", end=' ')
        import sys
        sys.stdout.flush()
        pass
    

    fromSAnames = set([sas[index].name() for index in fromSAindices])
    toSAnames = set([sas[index].name() for index in toSAindices])
    peakToPAname={}
    paScore={}
    paToSApairIndex={}
    totPAs=0
    

    if initScoresFrom=="contacts":
        from cdsMatrix import CDSMatrix_int as IMat
        resPairPassed = IMat(len(residues),len(residues),0)
        for a,b in knownContacts:
            aSel = convertToAtomSel(a,selection.simulation())
            aSegsResids=getSegsResidues(aSel)
            bSel = convertToAtomSel(b,selection.simulation())
            bSegsResids=getSegsResidues(bSel)

            for aSeg,aResidResnames in list(aSegsResids.items()):
                for aResid in [e.resid for e in aResidResnames]:
                    aIndex = residuesToIndex[aSeg][aResid]
                
                    for bSeg,bResidResnames in list(bSegsResids.items()):
                        for bResid in [e.resid for e in bResidResnames]:
                            bIndex = residuesToIndex[bSeg][bResid]
                            
                            resPairPassed[aIndex,bIndex] = 1
                            pass
                        pass
                    pass
                pass
            pass
        pass

    for pot in pots:
        for peak in pot.peaks():
            acceptablePAs=[]
            acceptableIntraPAs=[]
            for pa in peak.peakAssignments():
                totPAs+=1

                if (pa.numFiltersFailed() <= failedFiltersCutoff and
                    pa.fromAssignmentName() in fromSAnames and
                    pa.toAssignmentName() in toSAnames              ):
                
                    
                    #
                    # initialize peak index
                    #
                    peakToPAname.setdefault(peak.name(),[]).append( pa.name() )
                    
                    if pa.name() in list(paToSApairIndex.keys()):
                        raise Exception("peak assignment name collision: "+
                                        pa.name())
                    #
                    # initialize peakAssignment scores and indexes
                    #
                    paScore[pa.name()] = 0
                    paToSApairIndex[pa.name()]= (
                        nameToSAindex[pa.fromAssignmentName()],
                        nameToSAindex[pa.toAssignmentName()]  )
                    i,j = paToSApairIndex[pa.name()]
                    
                    acceptablePAs.append(pa)
                    
                    if not preferIntra: continue
                    
                    if ( pa.isIntraresidue() or
                         (pa.isSequential() and
                          atomSel.intersect(bbSel,pa.fromProtonSelection()) and
                          atomSel.intersect(bbSel,pa.toProtonSelection())   )):
                        acceptableIntraPAs.append( pa )
                        pass
                    pass
                pass

            #
            # set starting PeakAssign scores for the acceptable PAs of this 
            # peak, generating scores in one of three ways:
            #    1.  their previous likelihoods 
            #    2.  number of acceptable intraresidue PAs in this peak (if 
            #        any)
            #    3.  total number of acceptable PAs in this peak
            #

            if initScoresFrom=="previous":
                for pa in acceptablePAs:
                    paScore[pa.name()]=pa.previousLikelihood()
                    pass
                pass
            elif initScoresFrom=="degen":
                if len(acceptableIntraPAs) > 0:
                    points = 1. / len(acceptableIntraPAs)
                    for pa in acceptableIntraPAs:
                        paScore[pa.name()]=points
                        pass
                    pass
                elif len(acceptablePAs)>0:
                    points = 1. / len(acceptablePAs)
                    for pa in acceptablePAs:
                        paScore[pa.name()]=points
                        pass
                    pass
                pass
            elif initScoresFrom=="uniform":
                for pa in acceptablePAs:
                    paScore[pa.name()]=1
                    pass
                pass
            elif initScoresFrom=="contacts":
                for pa in acceptableIntraPAs:
                    paScore[pa.name()]=1
                    pass
                for pa in acceptablePAs:
                    for resPair in resPairForPA(pa):
                        if resPairPassed[resPair]:
                            paScore[pa.name()]=1
                            break
                            pass
                        pass
                    pass
                pass
            else: raise Exception("invalid value for initScoresFrom: " +
                                  initScoresFrom)
            pass
        pass
    
    if verbose: print(" %d total"%totPAs)
            
    #
    # iterate:
    #
    for iter in range(numIters):
        if verbose and verbose>1:
            print("net filter iteration %d of %d \r" %(iter,numIters))
            pass
        
	    
	#
	# Re-initialize raw SA pair scores from current PA scores
	# If > 1 PeakAssignment corresponds to a particular pair of SAs,
	# use the maximum PA score for the raw SA pair score
	#
        rawSAPairScore.set(0.)

        for paName in list(paScore.keys()):
            ij= paToSApairIndex[paName]
#            print "paToSApairIndex: %s %s %s" % (paName,
#                                                 sas[ij[0]].name(),
#                                                 sas[ij[1]].name(),)
#                                                 
            rawSAPairScore[ij] = max(rawSAPairScore[ij],paScore[paName])
            pass


	#
	# calculate residue pair scores over their neighborhoods
	#
#	
#	array unset residuePairScore 
#	
        residuePairCount=0
        nResiduePairs = len(residues)**2
        resPairScore=RMat(len(residues),len(residues),0)

        sumScores=0
        for resI in range(len(residues)):
            for resJ in range(len(residues)):
                residuePairCount += 1
                if verbose and verbose>2:
                    print("Iteration %d of %d: " %(iter,numIters), end=' ')
                    print("Calculating residue pair scores ", end=' ')
                    print("(%d of %d) \r" %(residuePairCount,nResiduePairs), end=' ')
                    pass

                curTot= 0
                numSAPairsInNeighborhood= 0
	    
		#
		# evaluate all the possible links in the residues'
		# neighborhoods
		# 
		# by default, avoid counting any pairs of SAs that are
		# to-from partners, since they don't generally have peaks or
		# peakAssignments 
		#
	    
                for fromSAi in fromSAsInResHood[resI]:
                    for toSAj in toSAsInResHood[resJ]:
                        if potNameForSA[fromSAi] != potNameForSA[toSAj]:
                            continue

                        
                        if ( expectDiagPAs or
                             toSAj != toFromPartner[fromSAi] ):

                            curTot += rawSAPairScore[fromSAi,toSAj]
                            numSAPairsInNeighborhood += 1
                            pass
                        pass
                    pass

                for toSAi in toSAsInResHood[resI]:
                    for fromSAj in fromSAsInResHood[resJ]:
                        if potNameForSA[toSAi] != potNameForSA[fromSAj]:
                            continue


                        if ( expectDiagPAs or
                             toSAi != toFromPartner[fromSAj] ):

                            curTot += rawSAPairScore[fromSAj,toSAi]
                            numSAPairsInNeighborhood += 1
                            pass
                        pass
                    pass
	    
                if numSAPairsInNeighborhood > 0:
                    resPairScore[resI,resJ] = curTot/numSAPairsInNeighborhood
                    sumScores += resPairScore[resI,resJ]
                    pass
                pass
            pass
        if verbose and verbose>2: print()

        print("sumScores: %.10f" % sumScores)
            
        

	#
	# renormalize respair scores relative to their members' intrares scores
	# and hang on to the raw intrares scores for reporting purposes
	#

        rawIntraresScores = [resPairScore[i,i] for i in range(len(residues))]
        intraresScores = [resPairScore[i,i] 
                          if resPairScore[i,i]>=minExpectedScore
                          else 1 for i in range(len(residues))]
        print("intraresScores: ", intraresScores)
                          

        from math import sqrt
        for i in range(len(residues)):
            for j in range(len(residues)):
                sAB = resPairScore[i,j]
                sAA = intraresScores[i]
                sBB = intraresScores[j]
                resPairScore[i,j] = sAB / sqrt(sAA*sBB)
                #print 'resPairScore:: %d %d %f' % (i,j,resPairScore[i,j])
                pass
            pass

	
	#
	# Now calculate new PA scores, by renormalizing the residue pair 
	# scores of each PA of each peak.  Note that peaks with low max peak 
	# scores get zeroed out entirely, to avoid mucking up the respair 
	# score with bad PAs' connections
	#
        if verbose and verbose>1:
            print("Iteration %d of %d: "%(iter,numIters), end=' ')
            print("Calculating new peakAssignment scores \r")

            print("Min peak score is %f" % minPeakScore)
            pass

        nPeaksZeroed= 0

	# FIX:  Need to ignore PAs with exceptions?  

        paScoreSum=0
        for peakName in list(peakToPAname.keys()):
	    
            peakTot= 0
            peakMax= -1
            peakNum = 0
            for paName in peakToPAname[peakName]:
                temp=[ resPairScore[resPair] for resPair in
                       saPairToResPair[paToSApairIndex[paName]] ]
                peakNum += len(temp)
                peakTot += max(temp)
                peakMax = max(peakMax,max(temp))
                pass
            if peakMax > minPeakScore:
                for paName in peakToPAname[peakName]:
                    temp=[ resPairScore[resPair] for resPair in
                           saPairToResPair[paToSApairIndex[paName]] ]

                    paScore[paName] = max(temp)/peakTot if peakTot>0 else 0
                    paScoreSum += paScore[paName]
                    pass
                pass
            else:
                nPAsZeroedInCurrentPeak= 0
                for paName in peakToPAname[peakName]:
                    paScore[paName] = 0
                    nPAsZeroedInCurrentPeak += 1
                    pass
                if nPAsZeroedInCurrentPeak>0:
                    nPeaksZeroed += 1
                    pass
                pass
            pass

        if verbose and verbose>1:
            print("\n\nIteration %d: num peaks zeroed %d\n\n" %(iter,
                                                                 nPeaksZeroed))
            numPassing=0
            for i in range(len(residues)):
                for j in range(len(residues)):
                    if resPairScore[i,j] > passFrac:
                        numPassing += 1
                        pass
                    pass
                pass
            print("  num passing:", numPassing)
            
            pass
        pass

    if verbose:
        print("Recording which peakAssignments passed the filter \r")
        pass

    #
    # for each residue, take highest-scoring nExpectedContacts residues, 
    # and declare them passed
    #

    from cdsMatrix import CDSMatrix_int as IMat
    resPairPassed = IMat(len(residues),len(residues),0)

    #
    # Residue pair scores have already been renormalized by their 
    # expected scores.  Therefore, a residue pair passes if its 
    # score is > passFrac
    #
    for i in range(len(residues)):
        for j in range(len(residues)):
            if resPairScore[i,j] > passFrac:
                resPairPassed[i,j] = 1
                pass
            pass
        pass
    
    #
    # make sure passed array is symmetric
    #
    for i in range(len(residues)):
        for j in range(len(residues)):
            if resPairPassed[i,j]: resPairPassed[j,i] = 1
            pass
        pass


    nResPairsPassed= 0
    for i in range(len(residues)):
        for j in range(len(residues)):
            if resPairPassed[i,j]: 
                nResPairsPassed += 1
                pass
            pass
        pass

    if verbose:
        print("%d of %d (%.2f%%) residue pairs passed" % (nResPairsPassed,
                                                        nResiduePairs,
                                                        100.*nResPairsPassed /
                                                        nResiduePairs))
        pass

    #
    # for each PA, declare it passed the filter if its corresponding residue 
    # pair passed the filter
    # 
    # Also, set previous likelihoods for each PA:
    #    if the PA's residue pair didn't pass the filter, set its likelihood 
    #    to zero
    #    if it did, set its likelihood to its 
    #    resPairScore / max(resPairScores) of all passing PAs of this peak
    #

    #FIX: Warn if knownContacts not present and add contact
    for a,b in knownContacts:
        aSel = convertToAtomSel(a,selection.simulation())
        aSegsResids=getSegsResidues(aSel)
        bSel = convertToAtomSel(b,selection.simulation())
        bSegsResids=getSegsResidues(bSel)

        for aSeg,aResidResnames in list(aSegsResids.items()):
            for aResid in [e.resid for e in aResidResnames]:
                aIndex = residuesToIndex[aSeg][aResid]
                
                for bSeg,bResidResnames in list(bSegsResids.items()):
                    for bResid in [e.resid for e in bResidResnames]:
                        bIndex = residuesToIndex[bSeg][bResid]

                        if not resPairPassed[aIndex,bIndex]:
                            print("Warning: missing contact between", end=' ')
                            print("%s %d and %s %d"%(aSeg,aResid,
                                                     bSeg,bResid))
                            resPairPassed[aIndex,bIndex] = 1
                            pass
                        pass
                    pass
                pass
            pass
        pass
    
        
        
        
    (nPAsPassed,
     nPAsFailed) = filterPAs(potsToFilter,resPairPassed,resPairScore)
    
    #
    # Create explicit inverse exceptions for all of the SA pairs 
    # belonging to the passing residue pairs,
    # whether or not they have a corresponding PA
    #
    # This includes all SAs, whether or not they were ignored for low 
    # likelihood.  SAs with missing proton shifts obviously don't have a 
    # residue, so they have no residue pair score, so this code won't do 
    # anything for them.
    #
    
    if createExceptions:

        nExceptionsCreated = {}
        if verbose:
            print("Creating explicit inverse exceptions for ShiftAssignment", end=' ')
            print("pairs")
            pass
        for pot in pots:
            potExceptions=[]
            for fromSA in pot.fromShiftAssignments():
                for toSA in pot.toShiftAssignments():
                    createException=False
                    key=tuple([nameToSAindex[sa.name()] for sa in (fromSA,
                                                                   toSA)])
                    for resPair in saPairToResPair[key]:
                        if resPairPassed[resPair]:
                            createException = True
                            break
                        pass

                    if createException:
                        pot.addException(fromSA.name(), toSA.name()  )
                        potExceptions.append( (fromSA.name(),toSA.name()) )
                        pass
                    pass
                pass
            if verbose and verbose>1:
                print("pot: %s # exceptions: %d" % (pot.instanceName(),
                                                    len(potExceptions)))
            nExceptionsCreated[pot.instanceName()] = len(potExceptions)
            pass
	
        pass
    

    if printResiduePairScores:
        #
        # to produce score-vs-distance figure for paper
        #
        print("                         resI resJ rawIntraScoreI", end=' ')
        print("rawIntraScoreJ resPairScore resPairPassed")
        for i,resI in enumerate(residues):
            for j,resJ in enumerate(residues):
                print("Final residue pair score %s %s %f %f %f %d" % \
                      ( str(resI), str(resJ),
                        rawIntraresScores[i], rawIntraresScores[j],
                        resPairScore[i,j], resPairPassed[i,j] ))
                pass
            pass
        pass

                
    #
    # eval performance, based on accuracy of passed PAs and passed inverse 
    # exceptions
    #

    remarks="New Network filter mini: \n"
    if includeBBSeq:
        remarks += "Added backbone-sequential shiftassignments to each "
        remarks += "residue's neighborhood\n"
        pass

    allScores     = []
    passingScores = []
    failingScores = []
    for resI in range(len(residues)):
        for resJ in range(len(residues)):
            allScores.append( resPairScore[resI,resJ] )
            if resPairPassed[resI,resJ]:
                passingScores.append( resPairScore[resI,resJ] )
            else:
                failingScores.append( resPairScore[resI,resJ] )
                pass
            pass
        pass

    from pasd import asciiHistogram
    remarks += asciiHistogram(allScores,
                              title="All residue pair scores")
    remarks += asciiHistogram(passingScores,
                              title="Passing residue pair scores")
    remarks += asciiHistogram(failingScores,
                              title="Failing residue pair scores")
    if createExceptions:
        for pot in pots:
            remarks += "created %d explicit inverse exceptions\n" % \
                       nExceptionsCreated[pot.instanceName()]
            val = 100.0 * float(nExceptionsCreated[pot.instanceName()]) / \
                  (len(pot.fromShiftAssignments()) *
                   len(pot.toShiftAssignments()))
            pass
        pass

    if tclOutput:
        # writeMarvinPeaks puts an extra newline after each list element
        ret=""
        ret = "{"+remarks+"}"
        return ret
    else:
        from collections import namedtuple
        RetType = namedtuple('NetFilter',['remarks',])
        return RetType(remarks)


