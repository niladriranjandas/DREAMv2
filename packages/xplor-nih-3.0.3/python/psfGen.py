"""Generate PSF information from sequence or coordinates.

Particularly useful are the pdbToPSF and seqToPSF routines.
"""

terminalAtoms = ['H5T','H3T']

# this dictionary will hold all residue names found in the corresponding
# topology file. It is built by deduceSeqType
residueTypes = {}
residueTypes['protein']=[]
residueTypes['nucleic']=[]
residueTypes['water']=[]
residueTypes['metal']=[]

class VariantResidue:
    def __init__(s,name,baseName,deletedAtoms):
        s.name=name
        s.baseName=baseName
        s.deletedAtoms=deletedAtoms.split(' ')
        pass
    

variantResidues = { 'protein' : [VariantResidue('HSD','HIS',
                                                deletedAtoms='HE2'),
                                 VariantResidue('HSE','HIS',
                                                deletedAtoms='HD1')]
                    }

residueMap={     'G' : 'GUA' ,   #single character residue names
		 'C' : 'CYT',    # - for nucleic acids only
		 'T' : 'THY',
		 'A' : 'ADE',
		 'I' : 'INO',
                 'U' : 'URI',
                 'DA': 'ADE',    # two character residue names for DNA
                 'DG': 'GUA',
                 'DC': 'CYT',
                 'DT': 'THY',
		 'HOH' : 'WAT',
		 }


failIfInsertion=True
class InsertionException(Exception):
    "Exception thrown by pdbToSeq if an insertion code is detected"
    def __init__(s):
        Exception.__init__(s,'Sequence has residue insertion(s).')
        return
    pass

class pdbRecordError(Exception):
    def __init__(self):
        Exception.__init__(self,
                           'Unable to extract information from pdbRecord')
    

from trace import notrace_decorate

@notrace_decorate
def pdbToSeq(pdbRecord,
             useSeqres=False,
             useChainID=True,
             processBiomt=False,
             **kwargs
             ):
    """Return sequence information generated by seqFromPDB or seqFromCIF.

    pdbRecord is a string with the contents of a PDB file, from which the
    sequence(s) is (are) obtained.

    If useChainID=True (default), and the chainID field is specified in
    pdbRecord, chainID overrides the segid field for naming segments; otherwise
    segid is used.  
    
    processBiomt specifies whether the REMARK 350 BIOMT record is used. By
    default, Biomolecule 1 is read, specifying a different integer to the
    processBiomt argument will read that entry.

    kwargs specifies the optional extra argument failIfInsertion.
    If failIfInsertion=False, a warning message will be printed and
    the residue will be skipped if the insertion code field of the
    ATOM record is not blank.  If failIfInsertion=True, an
    InsertionException will be raised if an iCode (insertion code) is
    encountered.  If the argument is omitted, the module-local
    variable of the same name will be used, and its default value is
    True.

    The return value is an object with three members: seqs, a list of
    tuples containing (beginResid,segid,seq), where seq is a list of
    residue names, biomt, which is populated if processBiomt=True, and
    an array altRecs which is populated by structures which have multiple
    sidechain conformations.
    """
    
    failIfInsertion=kwargs.pop('failIfInsertion',-1)
    includeHETATM=kwargs.get('includeHETATM',False)

    from pdbTool import PDBTool
    pdb = PDBTool()
    pdb.setContents(pdbRecord)
    format = pdb.determineFormat()

    import psfGen
    if failIfInsertion==-1: failIfInsertion=psfGen.failIfInsertion
    if format=="PDB":
        return seqFromPDB(pdbRecord,
                          useSeqres,
                          useChainID,
                          processBiomt,
                          failIfInsertion,
                          includeHETATM,
                          )
    elif format=="CIF":
        if includeHETATM:
            raise Exception("includeHETATM=True not yet support for CIF files")
        return seqFromCIF(pdbRecord,
                          useSeqres,
                          processBiomt,
                          failIfInsertion,
                          )
    else:
        raise Exception("format of pdbRecord unknown")
    return

# a dictionary with residuename, tag atom name identifiers. This is used
# to identify sidechain coordinates to be placed in the altRecs member of the
# seqFromPDB return object
tagResids={'CYSP' : "OS1"} 

def seqFromPDB(pdbRecord,
               useSeqres=False,
               useChainID=True,
               processBiomt=False,
               failIfInsertion=-1,
               includeHETATM=False,
               ):
    """Return an object with a seqs attribute. This attribute is a list of
    (startResid, segid, seq) tuples, where seq is a list of residue names.

    pdbRecord is a string with the contents of a PDB file, from which the
    sequence(s) is (are) obtained.

    If useChainID=True (default), and the chainID field is specified in
    pdbRecord, chainID overrides the segid field for naming segments; otherwise
    segid is used.  
    
    processBiomt specifies whether the REMARK 350 BIOMT record is used. By
    default, Biomolecule 1 is read, specifying a different integer to the
    processBiomt argument will read that entry. In this case, the return value
    will contain a biomt attribute with this information.

    If failIfInsertion=False, a warning message will be printed and
    the residue will be skipped if the insertion code field of the
    ATOM record is not blank.  If failIfInsertion=True, an
    InsertionException will be raised if an iCode (insertion code) is
    encountered.  If the argument is omitted, the module-local
    variable of the same name will be used, and its default value is
    True.  """
    seqs = []
    seq=[]
    curSeg=0
    curResid=None
    altRecs={} # segid,resid, newSegid
    terminate=0
    seg='    '
    remarks350=[]
    resid=None
    lostRes=''  #resid lost if no TER or terminal atoms
    previousTerminate=0 #true if one termination atom has been seen
    beginResid=None
    lines=pdbRecord.split('\n')
    from pdbFormat import getAtomEntry
    residSkip=False
    for line in lines:
        if line.startswith('ATOM') or (includeHETATM and
                                       line.startswith('HETATM')):
            res = getAtomEntry('resName',line)
            try:
                resid = int( getAtomEntry('resSeq',line) )
            except ValueError:
                raise Exception("unable to read residue number in entry:\n"+
                                line)
            icode = getAtomEntry('iCode',line) 
            if icode!=' ':
                print('pdbToSeq: Warning. Found insertion code in record:')
                print('  ', line)
                if failIfInsertion:
                    raise InsertionException
                continue
            if beginResid==None: beginResid=resid
            seg = getAtomEntry('segID',line).strip()
            seg += ' '*(4-len(seg)) # this for truncated ATOM records
            chainID=getAtomEntry('chainID',line)
            if useChainID and chainID!=' ':
                seg = chainID
                pass
            if curSeg==0:
                curSeg=seg
                #print 'curSeg initiated: ', curSeg, chainID, len(seg)
                pass
            atom = getAtomEntry('name',line).strip()  # atom name
            if seq:
                if seg!=curSeg:
                    if (res in tagResids and
                        (seg[0] in [r[1] for r in seqs] or
                         curSeg==''                     or
                         seg[0]==curSeg[0]               )):
                        #FIX: need to duplicate only sidechain atoms
                        # so need to record tag atom names
                        existingSegid = '' if  curSeg=='' else seg[0]
                        if curSeg not in altRecs: altRecs[curSeg]={}
                        if resid not in altRecs[curSeg]:
                            altRecs[curSeg][resid]={}
                            pass
                        if seg not in altRecs[curSeg][resid]:
                            altRecs[curSeg][resid][seg] = []
                            pass
                        altRecs[curSeg][resid][seg].append(atom)
                        #altRecs.append( (existingSegid,resid,seg) )
                        pass
                    else:
                        terminate=1
                        lostRes=res
                        pass
                    pass
                elif curResid and resid!=curResid and resid!=curResid+1:
                   #print "resid change termination >%d< >%d<" % ( curResid,
                   #                                               resid)
                   #print "  len seq:", len(seq)
                   terminate=1
                   residSkip=True
                   lostRes=res
                #print resid, curResid
                elif len(seq)>1 and atom in terminalAtoms:
                    #print "found terminal atom", len(seq)
                    if previousTerminate:
                        terminate=1
                        previousTerminate=0
                        lostRes=res
                    else:
                        previousTerminate=1
                        pass
                    pass
                pass
            if not terminate and resid!=None and resid!=curResid:
                seq.append(res)
                pass
            pass
        elif useSeqres and line.startswith('SEQRES'):
            return seqres(lines)
        elif line.startswith('TER'):
            terminate=1
        elif line.startswith('ENDMDL'):
            break
        elif line.startswith('REMARK 350'):
            remarks350.append(line)
            pass
        if terminate:
            if seq:
                seqs.append((beginResid,curSeg,seq))
                seq=[]
                previousTerminate=0
                beginResid=None
                curSeg=0
                if lostRes and residSkip:
                    residSkip=False
                    seq=[lostRes]
                    beginResid=resid
                    curSeg=seg
                    pass
                pass
            elif lostRes:
                seqs.append(beginResid,curSeg,[lostRes])
                beginResid=None
                curSeg=0
                pass
            #print 'terminate:', seqs[-1]
            previousTerminate=0
            res=None
            terminate=0
            lostRes=''
            curResid=beginResid
        else:
            curResid=resid
            pass
        pass
    if seq: seqs.append( (beginResid,curSeg,seq) )
    
    if not seqs: raise pdbRecordError
    
    class PDBToSeqClass:
        pass
    ret=PDBToSeqClass()
    ret.seqs=seqs
    ret.biomt=None
    ret.altRecs = altRecs

    if processBiomt:
        ret.biomt=processBiomtEntries(remarks350,
                      biomol=processBiomt if processBiomt!=True else 1)
        pass
    return ret


def seqres(lines):
    """Read the pdb SEQRES field and return a list of lists of sequences.

    SEQRES fields include chain specifiers. If this is blank the segid
    is set from the first ATOM entry.
    """
    from simulationWorld  import SimulationWorld_world as simWorld
    if simWorld().logLevel()!='none':
        print("using seqres field")
        pass
    records = [x for x in lines if x.startswith('SEQRES')]

    chains={}
    for record in records:
        record = record[:min(len(record),72)]
        id=record[11]
        residues=record[19:].split()
        if id in chains:
            chains[id] += residues
        else:
            chains[id] = residues
            pass
        pass
    ids=list(chains.keys())
    ids.sort()
    ret=[]
    for id in ids:
        ret.append( [1,id,chains[id]] )
        pass

    #get segment names, if chainids are not specified
    if ret[0][1]!=' ':
        return ret

    segs=[]
    chainCnt=0
    prevChainID=''
    for line in lines:
        if line.startswith('ATOM'): 
            seg = line[72:76].strip()
            chainID=line[21]
            if prevChainID and chainID!= prevChainID:
                chainCnt+=1
                pass
            prevChainID=chainID
            resid = int(line[23:26])
            if ret[chainCnt][1]==' ':
                ret[chainCnt][1]=seg
                pass
            if chainCnt+1 >= len(ret):
                break

            if resid>=ret[chainCnt+1][0]:
                chainCnt+=1
                pass
            pass
        pass

    return ret
        

def autoProcessPdbSSBonds(pdbRecord):
    """ scan a PDB file for PDB SSBOND header fields.
    call addDisulfideBond as appropriate

    Returns a list of lines which contain SSBOND records.

    If an insertion code is found for a particular residue number, that
    SSBOND entry is skipped.

    """
    from simulationWorld  import SimulationWorld_world as simWorld

    lines=pdbRecord.split('\n')
    records = [x for x in lines if x.startswith('SSBOND')]

    if len(records) > 0:
        if simWorld().logLevel()!='none':		   
            print("using ssbond field")
            pass
        pass
    
    for record in records:

        """ These character positions are hard-wired into tbe PDB format """
        
        fromChainName = record[15:17].strip()
        fromResNum = record[18:21]
        toChainName = record[29:31].strip()
        toResNum = record[32:35]

        if record[21]!=' ' or (len(record)>35 and record[35]!=' '):
            print("autoProcessPdbSSBonds: Warning: ", end=' ')
            print("found insertion code in the record\n  ")
            print(record)
            print("  skipping")
            continue
        
        if len(fromChainName) > 0:
            fromSel = "(segid " + fromChainName + " and resid " + fromResNum + ")"
        else:
            fromSel = "(resid " + fromResNum + ")"
            pass

        if len(toChainName) > 0:
            toSel = "(segid " + toChainName + " and resid " + toResNum + ")"
        else:
            toSel = "(resid " + toResNum + ")"
            pass
                
        addDisulfideBond(fromSel, toSel)
        pass
    return records

def seqFromCIF(pdbRecord=None,
               cif=None,
               useSeqres=False,
               processBiomt=False,
               failIfInsertion=-1,
               ):
    """Return a list of list of sequences for an input record in mmCIF format-
    either as a string using the pdbRecord argument or as a
    <m cif>.Cif object using the cif argument.

    pdbRecord is a string with the contents of a PDB file, from which the
    sequence(s) is (are) obtained.

    processBiomt specifies whether the REMARK 350 BIOMT record is used. By
    default, Biomolecule 1 is read, specifying a different integer to the
    processBiomt argument will read that entry.

    If failIfInsertion=False, a warning message will be printed and
    the residue will be skipped if the insertion code field of the
    ATOM record is not blank.  If failIfInsertion=True, an
    InsertionException will be raised if an iCode (insertion code) is
    encountered.  If the argument is omitted, the module-local
    variable of the same name will be used, and its default value is
    True.  """

    if pdbRecord!=None:
        from cif import Cif
        cifData = Cif()
        cifData.setNumDatablocksToRead(1)
        cifData.setModelToRead(1)
        cifData.parse(pdbRecord)
        if not "pdbx_PDB_model_num" in cifData:
            cifBlock=cifData[cifData.keys()[0]]
            if 'atom_site' in cifBlock:
                atom_site = cifBlock.atom_site
                #reparse if there is no model number
                if not "pdbx_PDB_model_num" in atom_site:
                    cifData.clear()
                    cifData.setModelToRead(-1)
                    cifData.parse(pdbRecord)
                    pass
                pass
            pass
    elif cif!=None:
        cifData=cif
    else:
        raise Exception("must specify one of pdbRecord or cif arguments")

    cifBlock=cifData[list(cifData.keys())[0]]

    segids=[]
    seqs=[]
    if useSeqres:
        if "pdbx_poly_seq_scheme" in cifBlock:
            segids = cifBlock.pdbx_poly_seq_scheme.asym_id
        if "entity_poly_seq" in cifBlock:
            seqs = cifBlock.entity_poly_seq.mon_id
        elif "entity_poly_seq_scheme" in cifBlock:
            seqs = cifBlock.entity_poly_seq_scheme.mon_id
            pass
        pass
    
    seqs = []
    seq=[]
    curSeg=0
    curResid=None
    terminate=0
    seg='    '
    remarks350=[]
    resid=None
    lostRes=''  #resid lost if no TER or terminal atoms
    previousTerminate=0 #true if one termination atom has been seen
    beginResid=None

    atomCat=cifBlock.atom_site
    resNames=list(atomCat.auth_comp_id)
    resids=list(atomCat.auth_seq_id)
    insCodes=list(atomCat.pdbx_PDB_ins_code) if "pdbx_PDB_ins_code" in \
              atomCat else []
    segids=list(atomCat.auth_asym_id)
    atomNames=list(atomCat.label_atom_id)
    for i in range(len(atomCat.group_PDB)):
        res   = resNames[i]
        try:
            resid = int(resids[i])
        except ValueError:
            raise Exception("unable to read residue number: "+
                            resids[i])

        if insCodes and not insCodes[i] in ('?','.'):
            print('seqFromCIF: Warning. Found insertion code:', \
                  insCodes[i])
            if failIfInsertion:
                raise InsertionException
            continue
        if beginResid==None: beginResid=resid
        seg = segids[i]
        seg += ' '*(4-len(seg)) # this for truncated ATOM records FIX: check
        if curSeg==0:
            curSeg=seg
            #print 'curSeg initiated: ', curSeg, chainID, len(seg)
            pass
        atom = atomNames[i]  # atom name
        if seq:
            if (seg!=curSeg or
                resid!=curResid and resid!=curResid+1):
                #print "seq change termination >%s< >%s<" % ( seg, curSeg)
                terminate=1
                lostRes=res
                #print resid, curResid
            elif len(seq)>1 and atom in terminalAtoms:
                #print "found terminal atom", len(seq)
                if previousTerminate:
                    terminate=1
                    previousTerminate=0
                    lostRes=res
                else:
                    previousTerminate=1
                    pass
                pass
            pass
        if not terminate and resid!=None and resid!=curResid:
            seq.append(res)
            pass
        if terminate and seq:
            seqs.append((beginResid,curSeg,seq))
            previousTerminate=0
            beginResid=None
            seq=[]
            curSeg=0
            if lostRes:
                seq.append(lostRes)
                beginResid=resid
                lostRes=''
                curSeg=seg
                pass
            terminate=0
            curResid=beginResid
        else:
            curResid=resid
            pass
        pass
    if seq: seqs.append( (beginResid,curSeg,seq) )
    
    if not seqs: raise pdbRecordError
    
    class PDBToSeqClass:
        pass
    ret=PDBToSeqClass()
    ret.seqs=seqs
    ret.biomt=None
    ret.altRecs={}
    #FIX this
#    if processBiomt:
#        ret.biomt=processBiomtEntries(remarks350,
#                      biomol=processBiomt if processBiomt!=True else 1)
#        pass
    return ret

def addResidueName(residueName,
                   systemType='protein'):
    """ Add the specified residue name to the set of valid residue names
    for the specified systemType. Valid system types are protein (the
    default), nucleic, water and metal.

    A side effect of this function is that <m atomSelLang>.abbreviations()
    are updated such that the abbreviation for the specified systemType
    includes resideName (in addition to all previously specified names).
    
    """
    residueTypes[systemType].append(residueName)
    import atomSelLang
    atomSelLang.addAbbreviation(systemType,
                                "resname " +
                                " ".join(residueTypes[systemType]))
    return
        

def grabResidueNames(file):
    """
    find all residue names in the given file.
    """
    import protocol
    file = protocol.genTopParFilename(file,suffix="top")
    import re
    ret=[]
    for line in open(file).readlines():
        hit = re.search(r"^ *resi[^ \t]*[ \t]+([^ \t\n!]+)",line,
                        re.IGNORECASE)
        if hit:
            ret.append( hit.group(1) )
            pass
        pass
    return ret

initResidueNames_first=True
def initResidueNames(forceReread=False):
    """Initialize residue names from the appropriate topology file names.
    These names come from the <m protocol>.topology dictionary.

    Residue names are initialized only on the first call, unless forceReread
    is set to True, in which case all current settings are erased, and residue
    names are reread.
    """
    global initResidueNames_first
   
    if not (initResidueNames_first or forceReread):
        return
    initResidueNames_first = False

    if forceReread:
        global residueTypes
        for key in residueTypes:
            residueTypes[key] = []
            pass
        pass

    import protocol
    for key in residueTypes:
        for name in grabResidueNames(protocol.topology[key]):
            addResidueName(name,key)
            pass
        #add in variant residue names
        if key in variantResidues:
            for name in [v.name for v in variantResidues[key]]:
                addResidueName(name,key)
                pass
            pass
        #add in single character residue names
        for singleCharResname in residueMap:
            if residueMap[singleCharResname] in residueTypes[key]:
                addResidueName(singleCharResname,key)
                pass
            pass
        #change keys: prot --> protein, dna --> nucleic
        pass
    return


def deduceSeqType(seq):
    """
    given a 3 character residue name, determine whether it's protein or
    nucleic acid. DNA/RNA disambiguation is not always possible. The
    default is RNA.

    To make this determination, residue names are obtain from the current
    values of the protein and nucleic topology files (set in <m protocol>).
    """
    ret='unknown'
    if not seq: return ret

    initResidueNames()

    #only recognize upper case residue names
    seq = [resname.upper() for resname in seq]
    
    firstRes=seq[0]
    if len(firstRes)>4:
        raise Exception("invalid residue name: " + firstRes)
    for type in residueTypes:
        if firstRes.strip() in residueTypes[type]: ret=type
        pass
    if ret=='unknown': return ret
    for res in seq:
        if len(res)>4:
            raise Exception("invalid residue name: " + res)
        res = res.strip()
        if not res in residueTypes[ret]:
            raise Exception("residue %s not of type %s in %s" %
                            (res,ret,repr(seq)))
        pass

    # attempt at DNA disambiguation
    if ret=='nucleic':
        ret = 'dna'
        if 'URI' in seq or 'URA' in seq: ret = 'rna'
        pass
    return ret

    
def renameResidues(seq):
    " single letter to three letter names- only for nucleic acids."
    ret = []
    for r in seq:
        r=r.strip()
        if r.upper() in residueMap:
            ret.append( residueMap[r] )
        else:
            ret.append(r)
            pass
        pass
    return ret

def cisPeptide(startResid,
                 segName=None):
    """
    given a startResid, set up topology to make a cis peptide bond between
    residues numbers startResid and startResid+1.

    Call this routine after seqToPSF.

    This function correctly treats bonds involving proline and non-proline
    residues.

    If the optional segName argument is not specified, peptide bonds
    in all segments with the matching startResid will be made cis.
    """

    import protocol
    if segName==None:
        from selectTools import getSegids
        segids = getSegids('resid %d' % startResid)
    else:
        segids = [segName]
        pass

    if not segids:
        raise Exception("cisPeptide: no residues selected")
    
    from xplorSimulation import getXplorSimulation
    xplor=getXplorSimulation()
    cmd=''
    for segid in segids:
        patch="CISP"
        from atomSel import AtomSel
        if len( AtomSel('resname PRO and resid %d and segid "%s"' %
                        (startResid+1, segid)) ):
            patch="CIPP"
            pass

        cnsTopology=False
        for pset in ("aria","eef"):
            if pset in protocol.topVersion['protein']:
                cnsTopology=True
                pass
            pass
        if cnsTopology:
            cmd += '''
            patch %s
              reference=nil=( resid %d and segid "%s") 
            end
            '''  % (patch,startResid,segid)
        else:
            cmd += '''
            patch %s
              reference=-=( resid %d and segid "%s")
              reference=+=( resid %d and segid "%s") 
            end
            '''  % (patch,startResid,segid,startResid+1,segid)
            pass
        pass
    outputState=xplor.disableOutput()
    xplor.command(cmd)
    xplor.enableOutput(outputState)

    import protocol
    protocol.updatePseudoAtoms()
    
    return

def dAmino(resid,
           segName='    '):
    """Change given residue to a D-amino acid.

    Call this routine after seqToPSF.

    The optional segName argument argument should be specified if there is
    more than one segment in the structure.
    """
    from xplorSimulation import getXplorSimulation
    xplor=getXplorSimulation()
    outputState=xplor.disableOutput()
    xplor.command('''
    patch LtoD 
      reference=nil=( resid %d and segid "%s")
    end''' % (resid,segName))
    xplor.enableOutput(outputState)

    import protocol
    protocol.updatePseudoAtoms()
    return
         

def seqToPSF(seq,
             seqType='auto',
             startResid=1,
             deprotonateHIS=True,
             segName='    ',
             disulfide_bonds=[],
             disulfide_bridges=[],
             amidate_cterm=False,
             ntermPatch=None,
             ctermPatch=None,
             customRename=False,
             sync=True,
             singleChar=False,
             psfFilename='',
             simulation=None):
    r"""Given a primary protein or nucleic acid sequence, generate PSF info
    and load the appropriate parameters.

    The seq argument can be a string or the name of a file containing the
    sequence.  In the file or string, lines which contain a '#' as the first
    nonwhitespace character are treated as comments, and ignored.

    If seqType is auto, the type (protein, dna, rna, water, metal) is
    determined from the sequence.  Type 'rna' must be explicitly specified.
    Normally, topology and parameters corresponding to seqType are initialized
    using <m protocol>.initTopology and initParams. seqType "custom" can be
    specified for stand-alone residue molecules; for this seqType topology and
    parameters are not loaded by this function, and must be loaded via an
    alternate mechanism.    

    If deprotonateHIS is True, the HD1 atom is deleted from Histidines. This is
    the default. Alternatively, deprotonateHIS can be specified as a sequence of
    residue numbers specifying which residues the HD1 atom should be deleted
    from. Histidine protonation state can also be specified using residue name
    variants HIS (fully protonated), HSD (HD1 present, no HE2), and HSE (HE2
    present, no HD1). If a histidine variant residue name is detected, the
    deprotonateHIS argument is ignored.

    If segName is shorter than four characters, leading characters are
    space-padded.  It is an error for it to be longer than 4 characeters.

    Disulfide bonds are specified by a list of resid pairs (numbers) in either
    disulfide_bonds or disulfide_bridges.  Use disulfide_bonds for actual bonds
    and disulfide_bridges to remove the cysteine HG proton- for representing
    disulfide bonds by NOE restraints.

    Customization of terminal protein residues is handled by the
    amidate_cterm, ntermPatch, and ctermPatch arguments.  If
    amidate_cterm is set to True, the C-terminus is amidated, else
    ctermPatch is used for the terminal residue (by default, this adds
    a second oxygen to the C-terminal carbon).  A custom patch can
    also be specified for the N-terminus using the ntermPatch
    argument (by default the terminal nitrogen atom will have three
    protons, or two if it's a proline).  Patch names must be specified
    in toppar/protein.top.  Blank values of ntermPatch or ctermPatch
    may be specified to suppress patching termini altogether. The
    default values for proteins are ntermPatch="NTER" and
    ctermPatch="CTER", while for nucleic acids they are "5TER" and
    "3TER", respectively.

    If customRename is set, certain convenient atom renamings are made for
    nucleic acids:
            ADE H61 --> HN'   
            ADE H62 --> HN''  
            GUA H21 --> HN'   
            GUA H22 --> HN''  
            CYT H41 --> HN'   
            CYT H42 --> HN''  
            THY C5A --> CM

    The sync argument specifies whether XPLOR arrays are copied back to
    the C++ interface.  This should almost always be the default value, True.

    If singleChar is set to True, the input sequence string is
    understood to be single character residue codes separated by zero
    or more spaces and newlines.

    If psfFilename (a string) is specified, the topology information is written
    to a file (i.e. the PSF file) named psfFilename.

    Protein and nucleic acids monomers are connected into a full
    polymer using PRESidue patch definitions in the topology
    definition. !LINK comments in the topology file(s) override the
    default values of 

           !LINK PEPP  HEAD - *   TAIL + PRO   END
           !LINK PEPT  HEAD - *   TAIL + *     END

    If any !LINK statement is specified, then the defaults are erased.
    """
    # Default settings for 'protein' result in peptide bonds and termini as 
    # defined in toppar/toph19.pep.  Guillermo A. Bermejo (Oct-13-2015)
    
    from xplorSimulation import getXplorSimulation
    xplor=getXplorSimulation(simulation)
    from simulationWorld import SimulationWorld_world as simWorld

    outputState=xplor.disableOutput()

    if len(segName)<4:
        segName="%-4s"%segName
    elif len(segName)>4:
        raise Exception("segName (%s) is too long" % segName)

    import os
    if type(seq)==type("string") and os.path.exists(seq):
        seq = open(seq).read()
        pass
            
    if type(seq)==type("string"):
        list=[line for line in seq.split("\n")
              if not line.lstrip().startswith('#')]
        seq = " ".join(list)
        if singleChar:
            seq=seq.replace(' ','')
            seq=seq.replace('\n','')
            seq=seq.replace('\r','')
            if seqType=='auto': seqType = 'protein'
            from selectTools import renameResidues
            if seqType=="nucleic":
                seq=renameResidues(seq,seqType)
            elif seqType.startswith("prot"):
                from selectTools import oneToThree
                seq=[oneToThree(c) for c in seq] 
            else:
                raise Exception("singleChar not understood for seqType=" +
                                seqType)
            pass
        else:
            seq = seq.split()
            pass
        pass

    if seqType=='auto': seqType = deduceSeqType(seq)

    if seqType=='prot': seqType = 'protein'


    #split up seq to avoid overlong line
    seqs=[[]]
    ind=0
    cnt=0
    variants={}
    for i,r in enumerate(seq):
        if len(r)>4:
            raise Exception("residue >%s< is too long. Is it a missing file?"%
                            r)
        #handle variants
        if seqType in variantResidues:
            for variant in variantResidues[seqType]:
                if r==variant.name:
                    variants[i+startResid] = variant
                    r = variant.baseName
                    pass
                pass
            pass
        
        if cnt>20:
            ind+=1
            seqs.append([])
            cnt=0
            pass
        seqs[ind].append( r )
        cnt+=1
        pass
    def join(seq,sep=' '):
        """backward compatibility"""
        return sep.join(seq)
    splitSeq = join([join(x) for x in seqs],'\n')
    #seq = join(seq)

    import protocol
    if seqType=='protein':
        protocol.initTopology("protein",simulation=simulation)#,reset=1)
        protocol.initParams("protein",simulation=simulation)

        #histidine variant special case - turn off deprotonateHIS
        if "HIS" in [v.baseName for v in variants.values()]:
            deprotonateHIS=False
            pass

        linkages = protocol.linkages['protein'] \
                   if seqType in protocol.linkages else []
        if not linkages:
            linkages = ["LINK PEPP  HEAD - *   TAIL + PRO   END",
                        "LINK PEPT  HEAD - *   TAIL + *     END"]
        linkStatement='\n'.join(linkages)

        if ctermPatch==None:
            ctermPatch="CTER"
            pass

        if amidate_cterm:
            ctermPatch = "CTN "
            pass
        if ctermPatch:
            cterm = "LAST  %s   HEAD - *                    END" % ctermPatch
        else:
            cterm=''
            pass
            
        if ntermPatch==None:
            ntermPatch="NTER"
            pass
        
        if seq[0]=='ACE':
            ntermPatch=''
            pass

        nterm=''
        if ntermPatch=="NTER":
            if ("charmm2" in protocol.topVersion['protein'] or
                "eef-2.0" in protocol.topVersion['protein']):
                nterm += r"""
                FIRSt GLYP               TAIL + GLY     END { nter for GLY }
                """
                pass
            
            nterm += r"""
            FIRSt PROP                TAIL + PRO     END { nter for PRO }
            FIRSt NTER                TAIL + *       END
            """
        elif ntermPatch:
            nterm = r"""
            FIRSt %s                TAIL + *       END
            """ % ntermPatch
            pass
        

        xplor.fastCommand('''
        REMARKS  autogenerated by psfGen.py
        segment
        name="%s"
        SETUP=TRUE
        number=%d
        ''' % (segName, startResid) + '''
        chain
        %s''' % linkStatement
        + r'''

        %s
        
        
        %s

        
        sequence %s
        end
        end
        end
        ''' % (nterm,cterm,splitSeq))

        if deprotonateHIS:
            if deprotonateHIS==True:
                xplor.fastCommand("delete select (name hd1 and resname his) end")
            else: #sequence of resids
                for resid in deprotonateHIS:
                    xplor.fastCommand(
                    'delete select (segid "%s" and name hd1 and resid %d) end'%
                    (segName,resid))
                pass
            pass

    elif seqType=='dna':
        protocol.initTopology("nucleic",simulation=simulation)#,reset=1)
        protocol.initParams("nucleic",simulation=simulation)

        if ntermPatch==None: ntermPatch="5TER" 
        if ctermPatch==None: ctermPatch="3TER" 
        

        linkages = protocol.linkages['nucleic'] \
                   if seqType in protocol.linkages else []
        if not linkages:
            linkages = ["LINK NUC  HEAD - *  TAIL + *  END"]
        linkStatement='\n'.join(linkages)

        xplor.fastCommand('''
        segment
        name="%s"
        SETUP=TRUE
        number=%d
        ''' % (segName, startResid) + r'''
        chain
        REMARKS  TOPH11.NUC  MACRO for RNA/DNA sequence
        REMARKS  autogenerated by psfGen.py

        ! this is a macro to define standard DNA/RNA polynucleotide bonds
        ! and termini to generate a sequence.
        ! it should be added as @TOPTRNA8.NUC in the SEGMent SEQUence
        ! level.
        ! 
        ! Axel Brunger, 17-AUG-84


        %s
        
        FIRST  %s  TAIL + * END

        LAST %s  HEAD - * END
        
        ''' % (linkStatement,ntermPatch,ctermPatch) + '''
        sequence %s
        end
        end
        end''' % splitSeq)


        for i in range(startResid,startResid+len(seq)):
            xplor.fastCommand('''patch DEOX
                                 reference=NIL=( segid "%4s" and resid %d )
                             end''' % (segName,i))
            pass

        if customRename:
            # rename some atoms
            xplor.fastCommand(r'''
            vector do (name "HN'")  ( NAME H61 AND RESNAME ADE )
            vector do (name "HN''")  ( name H62 and resname ADE )
            vector do (name "HN'")  ( name H21 and resname GUA )
            vector do (name "HN''")  ( name H22 and resname GUA )
            vector do (name "HN'")  ( name H41 and resname CYT )
            vector do (name "HN''")  ( name H42 and resname CYT )
            vector do (name "CM")   ( name C5A and resname THY )
            ''')
            pass
        
    elif seqType=='rna':
        protocol.initTopology("nucleic",simulation=simulation)#,reset=1)
        protocol.initParams("nucleic",simulation=simulation)

        if ntermPatch==None: ntermPatch="5TER" 
        if ctermPatch==None: ctermPatch="3TER" 

        linkages = protocol.linkages['nucleic'] \
                   if seqType in protocol.linkages else []
        if not linkages:
            linkages = ["LINK NUC  HEAD - *  TAIL + *  END"]
        linkStatement='\n'.join(linkages)

        xplor.fastCommand('''
        segment
        name="%s"
        SETUP=TRUE
        number=%d
        ''' % (segName, startResid) + r'''
        chain
        REMARKS  TOPH11.NUC  MACRO for RNA/DNA sequence
        REMARKS  autogenerated by psfGen.py

        ! this is a macro to define standard DNA/RNA polynucleotide bonds
        ! and termini to generate a sequence.
        ! it should be added as @TOPTRNA8.NUC in the SEGMent SEQUence
        ! level.
        ! 
        ! Axel Brunger, 17-AUG-84


        %s
        
        FIRST  %s  TAIL + * END

        LAST %s  HEAD - * END
        
        ''' % (linkStatement,ntermPatch,ctermPatch) + '''
        sequence %s
        end
        end
        end'''  % splitSeq)


        if customRename:
            # rename some atoms
            xplor.fastCommand(r'''
            vector do (name "HN'")  ( NAME H61 AND RESNAME ADE )
            vector do (name "HN''")  ( name H62 and resname ADE )
            vector do (name "HN'")  ( name H21 and resname GUA )
            vector do (name "HN''")  ( name H22 and resname GUA )
            vector do (name "HN'")  ( name H41 and resname CYT )
            vector do (name "HN''")  ( name H42 and resname CYT )
            vector do (name "CM")   ( name C5A and resname THY )
            ''')
            pass
        
    elif seqType=='water' or seqType=='metal'or seqType=='custom':
        if seqType!='custom':
            protocol.initTopology(seqType,simulation=simulation)
            protocol.initParams(seqType,simulation=simulation)
            pass

        xplor.fastCommand('''
        segment
        name="%s"
        SETUP=TRUE
        number=%d
        ''' % (segName, startResid) + r'''
        chain
        sequence %s
        end
        end
        end''' % splitSeq)
        pass
    else:
        from simulationWorld  import SimulationWorld_world as simWorld
        if simWorld().logLevel()!='none':
            print("seqToPSF: Warning: ",\
                  "unsupported sequence type: %s:" % seqType, splitSeq)
        pass

    for (res1,res2) in disulfide_bonds:
        xplor.fastCommand('''
        patch DISU 
          reference=1=( segid "%4s" and resid %d )  
          reference=2=( segid "%4s" and resid %d )  
        end''' % (segName,res1,segName,res2))
        pass
    
    for (res1,res2) in disulfide_bridges:
        xplor.fastCommand('''
        patch DISN
          reference=1=( segid "%4s" and resid %d )  
          reference=2=( segid "%4s" and resid %d )  
        end''' % (segName,res1,segName,res2))
        pass

    for resid,variant in variants.items():
        for atomName in variant.deletedAtoms:
            xplor.fastCommand("""
            delete select (segid "%s" and name %s and resid %d) end""" %
                              (segName,atomName,resid))
            pass
        pass

    xplor.enableOutput(outputState)

    if sync:
        xplor.syncFrom()
        import simulation
        simulation.syncAllSimulations()
        import protocol
        protocol.updatePseudoAtoms()
        pass

    if psfFilename:
        xplor.command("write psf output=%s end" % psfFilename)
        pass

        
    return

def renameAtoms(sel='all'):
    from atomSel import AtomSel
    if type(sel)==type('string'): sel = AtomSel(sel)

    for atom in sel:
        name=atom.atomName()

        if name.find("*")>=0: name = name.replace("*","'")

        atom.setAtomName(name)
        pass
    return


def pdbToPSF(pdbRecord='',
             psfFilename='',
             useChainID=True,
             customRename=False,
             processSSBonds=True,
             processBiomt=False,
             suppressExceptions=False,
             **kwargs
             ):
    """Generate XPLOR PSF structure/topology information from a PDB file.

    pdbRecord is a string with either the name of the PDB file or a string
    containing PDB contents.  If it is blank (default), no new PSF information
    is generated.

    If psfFilename is specified, the PSF is written to the specified file
    after pdbRecord is processed.

    If useChainID=True (default), and the chainID field is specified in
    pdbRecord, chainID overrides the segid field for naming segments; otherwise
    segid is used.  
    
    processSSBonds specifies whether the SSBOND PDB record is used in PSF
    generation.

    See seqToPSF for documentation on customRename and processBiomt.

    Setting suppressExceptions to True will cause exceptions due to failures in
    seqToPSF to be caught, allowing partial processing of mal-formed PDB files.

    If pdbRecord contains a BIOMT record, and processBiomt is True, then
    the BIOMT record is returned.
    """
    from xplorSimulation import getXplorSimulation
    xplor = getXplorSimulation()
    deprotonateHIS = kwargs.pop('deprotonateHIS', False)

    try:
        import os
        os.stat(pdbRecord)
        pdbRecord = open(pdbRecord).read()
    except:
        pass  # assume pdbRecord is a string with PDB file contents

    outputState=xplor.disableOutput()
    biomt=None
    if pdbRecord:
        # (Next line raises pdbRecordError if above assumption is wrong.)
        pdbToSeqRet= pdbToSeq(pdbRecord,processBiomt=processBiomt,
                              useChainID=useChainID,
                              **kwargs)
        sequences=pdbToSeqRet.seqs

        for (beginResid, segid, seq) in sequences:
            seq = renameResidues(seq)
            if segid=='*': segid=''
            #print type, beginResid, segid, seq
            try:
                seqToPSF(seq,seqType='auto', startResid=beginResid,
                         segName=segid, deprotonateHIS=deprotonateHIS,
                         customRename=customRename, sync=False)
            except Exception as mess:
                if suppressExceptions:
                    print("pdbToPSF: Warning: failed to process a sequence:")
                    print("  ",mess)
                    pass
                else:
                    raise
                pass
            pass
        
        xplor.syncFrom()
        import simulation
        simulation.syncAllSimulations()
    
        if processSSBonds:
            autoProcessPdbSSBonds(pdbRecord)
            pass

        altRecs=pdbToSeqRet.altRecs
        for segid0,namesSegidsBySegid in list(altRecs.items()):
            for resid,namesBySegid in list(namesSegidsBySegid.items()):
                for segid,names in list(namesBySegid.items()):
                    nameSel = " or ".join([" name %s"%name for name in names])
                    duplicateSegment(segid0,segid,resid,fast=True,
                                     nameSel=nameSel)
                    pass
                xplor.fastCommand('''delete
                                       sele=(segid "%s" and resid %d
                                             and (%s))
                                       end
                                  '''% (segid0,resid,nameSel))
                pass
            pass
    
        xplor.syncFrom()
        import simulation
        simulation.syncAllSimulations()

        biomt = pdbToSeqRet.biomt
        if biomt:
            for label in biomt.labels():
                for chain in biomt.chains:
                    duplicateSegment(chain,chain+label)
                    pass
                pass
            pass

        xplor.syncFrom()
        simulation.syncAllSimulations()
        pass
    
    if psfFilename:
        xplor.command("write psf output=%s end" % psfFilename)

    #renameAtoms()
    import protocol
    protocol.updatePseudoAtoms()
        
    xplor.enableOutput(outputState)
    return biomt

def addDisulfideBond(sel1, sel2, bond=True):
    """Add a disulfide bond between residues in the two atom selections.

    This function should be called after PSF information is generated.  sel1 and
    sel2 can be either selection strings or <m atomSel>.AtomSel instances.  For
    example, adding a disulfide bond between residues 8 and 50 can be done by:

    psfGen.addDisulfideBond('resid 8', 'resid 50')  # psfGen already imported

    The gamma protons are removed from both residues.  Additionally, if the bond
    argument is set to True (default), a covalent bond is added between the
    sulfur atoms.  Otherwise, if bond is False, the bonding step is omitted, and
    the disulfide bond has to be externally enforced as a distance restraint
    (for an example see http://nmr.cit.nih.gov/xplor-nih/xplorMan/node391.html).

    If atoms required for the given disulfide bond are not present, a
    UserWarning exception is thrown.
    
    """

    from atomSel import AtomSel
    if isinstance(sel1,str): sel1 = AtomSel(sel1)
    if isinstance(sel2,str): sel2 = AtomSel(sel2)

    if sel1.simulation().name() != sel2.simulation().name():
        raise Exception("no disulfide bond between different Simulations!")

    from xplorSimulation import getXplorSimulation    
    xSim = getXplorSimulation(sel1.simulation())

    if (len(sel1)==0 or
        len(AtomSel('segid "%s" and resid %d and name SG'%
                    (sel1[0].segmentName(),sel1[0].residueNum())))==0):
        raise UserWarning("No sulfur atom in "+sel1.string())
    if (len(sel2)==0 or
        len(AtomSel('segid "%s" and resid %d and name SG'%
                    (sel2[0].segmentName(),sel2[0].residueNum())))==0):
        raise UserWarning("No sulfur atom in "+sel2.string())
    
    if bond is True:
        xSim.command("""patch
                           DISU reference=1=( segid "%s" and resid %d )
                                reference=2=( segid "%s" and resid %d )
                         end""" % (sel1[0].segmentName(),sel1[0].residueNum(),
                                   sel2[0].segmentName(),sel2[0].residueNum()))
    elif bond is False:
        xSim.command("""patch
                           DISN reference=1=( segid "%s" and resid %d )
                                reference=2=( segid "%s" and resid %d )
                         end""" % (sel1[0].segmentName(),sel1[0].residueNum(),
                                   sel2[0].segmentName(),sel2[0].residueNum()))        
    return

def duplicateSegment(segid,
                     newSegid,
                     resid=None,
                     nameSel="all",
                     fast=False):
    """
    generate psf info for a new segment which is identical to an existing
    segment, with only different segid.
    """
    from xplorSimulation import getXplorSimulation
    xsim=getXplorSimulation()
    cmd = xsim.fastCommand if fast else xsim.command
    if resid==None:
        cmd('duplicate selection=((%s) and segid "%s") segid=%s end' %
                     (nameSel,segid,newSegid))
    else:
        cmd('''duplicate
                 selection=((%s) and segid "%s" and resid %d)
                 segid=%s
               end''' % (nameSel,segid,resid,newSegid))
    return        
    

class Biomt:
    """
    class containing info from a BIOMT record for generating new chains related
    by rotation+ translation to specified ATOM entries.

    Members are chains, rot, trans.
    """

    class BiomtEntry:
        def __init__(s,rot,trans):
            s.rot=rot
            s.trans=trans
            return
        pass
    def __init__(s,chains):
        s.chains=chains
        s.entries={}
        return
    def addEntry(s,key,rot,trans):
        s.entries[key] = s.BiomtEntry(rot,trans)
        return
    def labels(s):
        ret=list(s.entries.keys())
        ret.sort()
        return ret
    def entry(s,label):
        return s.entries[label]
        
    pass

def processBiomtEntries(remark350,
                        biomol=1):
    """
    Read info for symmetric subunits generated by BIOMT entries.

    This will read the entry for the biomolecule labelled biomol.

    Non-trivial (rotation/translation) transformations are read and stored
    along with the specified chain ids, and returned in a Biomt object
    """
    entries=[]
    for line in remark350:
        entries.append(line[10:].strip())
        pass
    ret = None
    curMolecule=False
    thisEntry=[]
    for entry in entries:
        if entry.startswith("BIOMOLECULE:"):
            cbiomol = int(entry.split(':')[1])
            print(cbiomol)
            if biomol==cbiomol:
                curMolecule=True
            else:
                curMolecule=False
                pass
            pass
        if curMolecule:
            thisEntry.append(entry)
            pass
        pass
    if not thisEntry:
        raise Exception("BIOMT record for Biomolecule %d not found" % biomol)

    for entry in thisEntry:
        if entry.startswith("APPLY THE FOLLOWING TO CHAINS:"):
            chains = entry.split(':')[1]
        elif entry.startswith("AND CHAINS:"):
            chains += entry.split(':')[1]
            pass
        pass
    chains = [c.strip() for c in chains.split(',')]
    ret = Biomt(chains)
    lines={}
    for entry in thisEntry:
        if entry.startswith('BIOMT'):
            (xyz,label,r1,r2,r3,t) = entry[5:].split()
            if not label in lines:
                lines[label]={}
                pass
            lines[label][xyz] = [float(s) for s in [r1,r2,r3,t]]
            pass
        pass
    from mat3 import Mat3
    from vec3 import Vec3
    biomts={}
    for l in lines:
        rot= Mat3(lines[l]['1'][0],lines[l]['1'][1],lines[l]['1'][2],
                  lines[l]['2'][0],lines[l]['2'][1],lines[l]['2'][2],
                  lines[l]['3'][0],lines[l]['3'][1],lines[l]['3'][2])
        trans= Vec3(lines[l]['1'][3],lines[l]['2'][3],lines[l]['3'][3])
        
        #remove trivial entries
        test=Mat3(1,0,0,
                  0,1,0,
                  0,0,1)-rot
        trivial=True
        for i in range(3):
            if abs(trans[i])>1e-3:
                trivial=False
            for j in range(3):
                if abs(test[i,j])> 1e-3:
                    trivial=False
                    pass
                pass
            pass
        if not trivial:
            ret.addEntry(l,rot,trans)
            pass

    print("BIOMT record processed for Biomolecule %d" % biomol)

    return ret

